# 环境配置和工具编译

## Linux远程开发机配置

- 安装或升级gcc/yasm/nasm
- 安装或升级make/cmake
- 安装或升级git，配置~/.gitconfig，配置密钥
- 安装universal-ctags
- 安装或升级vim (+python3支持)，配置~/.vimrc，安装插件

## 工具安装或升级

若需要源码编译，建议在特定目录下进行

```
test -d ~/tools/selfinstall || mkdir -p ~/tools/selfinstall
cd ~/tools/selfinstall
```

### GCC

#### 使用devtoolset

```
# 升级到7.x.x
sudo yum install centos-release-scl
sudo yum install devtoolset-7-gcc devtoolset-7-gcc-c++  # devtoolset-7-gcc*

# 使用设置
scl enable devtoolset-7 bash        # shall execute for every terminai
source /opt/rh/devtoolset-7/enable
```

#### 源码编译安装(v7.3.0)

下载gcc-7.3.0的源码并解压，并下载依赖的gmp、mpc、mpfr，解压到gcc-7.3.0的根目录下

```
cd gcc-7.3.0
tar -xjf gmp-6.1.0.tar.bz2 && ln -s gmp-6.1.0 gmp
tar -xzf mpc-1.0.3.tar.gz && ln -s mpc-1.0.3 mpc
tar -xjf mpfr-3.1.4.tar.bz2 && ln -s mpfr-3.1.4 mpfr
mkdir build
cd build
../configure --disable-multilib --enable-languages=c,c++ --enable-checking=release --prefix=/usr/local/gcc-7.3.0
make -j 8
make install
export PATH=/usr/local/bin:$PATH
```

若gmp/mpc/mpfr不存在，编译时会报错
```
configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.
Try the --with-gmp, --with-mpfr and/or --with-mpc options to specify
their locations.  Source code for these libraries can be found at
their respective hosting sites as well as at
ftp://gcc.gnu.org/pub/gcc/infrastructure/.  See also
http://gcc.gnu.org/install/prerequisites.html for additional info.  If
you obtained GMP, MPFR and/or MPC from a vendor distribution package,
make sure that you have installed both the libraries and the header
files.  They may be located in separate packages.
```

### GLIBC编译和安装(v2.18)

```
wget http://mirrors.ustc.edu.cn/gnu/libc/glibc-2.18.tar.gz
tar -zxvf glibc-2.18.tar.gz
cd glibc-2.18
mkdir build
cd build
../configure --prefix=/usr
make -j4
sudo make install
```

### Git

```
# 安装依赖
sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker
sudo yum install asciidoc xmlto
wget https://github.com/git/git/archive/refs/tags/v2.39.2.tar.gz -O git-v2.39.2.tar.gz
tar -xzf git-v2.39.2.tar.gz
cd git-2.39.2
source /opt/rh/devtoolset-7/enable  # 否则会报错"Required C99 support is in a test phase"

# 方法1
make prefix=/usr/local all doc info
sudo make prefix=/usr/local install install-doc install-html install-info

# 方法2
make configure
./configure --prefix=/usr/local
make all
sudo make install install-doc install-html
```

#### 报错/usr/local/lib64/libcrypto.so: undefined reference to 'dlopen'

打开Makefile目录，搜索LIB_4_CRYPTO，前面添加-ldl

```
ifdef NEEDS_SSL_WITH_CRYPTO
  LIB_4_CRYPTO = $(OPENSSL_LINK) -ldl -lcrypto -lssl
else
  LIB_4_CRYPTO = $(OPENSSL_LINK) -ldl -lcrypto
endif
```

### universal-ctags

```
# 方法1：预编译二进制安装
wget https://github.com/universal-ctags/ctags-nightly-build/releases/download/2024.10.05%2Becf0c4adcce9853d666590bf2be101f983bad1cf/uctags-2024.10.05-linux-x86_64.tar.gz
tar -xzf uctags-2024.10.05-linux-x86_64.tar.gz
cd uctags-2024.10.05-linux-x86_64
sudo cp bin/* /usr/local/bin
sudo cp bin/* /usr/local/bin

# 方法2：源码编译安装
git clone https://github.com/universal-ctags/ctags.git
git checkout v6.1.0
./autogen.sh
./configure --prefix=/usr/local
make
sudo make install
```

### Vim

```
# Centos升级安装VIM8
sudo yum remove vim-common vim-enhanced vim-filesystem
sudo wget -P /etc/yum.repos.d/ https://copr.fedorainfracloud.org/coprs/lbiaggi/vim80-ligatures/repo/epel-7/lbiaggi-vim80-ligatures-epel-7.repo
sudo yum install vim-enhanced
sudo ln -s /usr/bin/diff /usr/share/vim/vim80diff

# 安装插件
git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
```

### MP4Box编译

```
./configure --static-mp4box --enable-debug
```

### X265编译

cmake增加-pg编译和链接选项，为了做gprof profiling，需要使用静态编译，动态编译无法分析动态库的函数耗时
```
cmake -DCMAKE_INSTALL_PREFIX=../bin/debug/ -DCMAKE_BUILD_TYPE=Debug -DENABLE_SHARED=OFF -DCMAKE_C_FLAGS=-pg -DCMAKE_CXX_FLAGS=-pg -DCMAKE_EXE_LINKER_FLAGS=-pg -DCMAKE_SHARED_LINKER_FLAGS=-pg -G "Unix Makefiles" ../source/
```

## AI环境配置

### GPU查询

GPU硬件状态查询

```
nvidia-smi
nvidia-smi dmon
nvidia-topo -m
```

GPU硬件性能分析工具
```
DLProf
PyProf
```

### GPU和CUDA

![CUDA](../../../figures/cuda.jpg)

上面这张图简要说明了CUDA的架构，CUDA其实是分为2个部分，一部分是用户态的CUDA Driver，一部分是CUDA Toolkit。安装驱动（GPU kelnel-mode driver）的时候，往往是通过下载官网驱动的方式，英伟达官方已经把驱动和CUDA Driver匹配的版本打包到一起了，因此安装完驱动之后，调用nvidia-smi，就会显示用户态的CUDA Driver版本。

![CUDA](../../../figures/CUDA-framework.png)

这是另一个版本的CUDA架构图，其中的CUDA Runtime和CUDA Libraries即为CUDA Toolkit。


重点概念：
- GPU和显卡：都属于硬件范畴
- Driver：同一个机器只能安装一个版本
- CUDA：可细分为多层，对于AI环境而言，主要分为CUDA Runtime API和CUDA Driver API
    - 几乎所有的框架程序（包括Torch），所使用的CUDA都是CUDA Runtime API
    - CUDA Runtime API是NVIDIA封装的上层接口，几乎所有的CUDA Application都是调用CUDA Runtime API，而CUDA Runtime API内部调用CUDA Driver API。所以通常所说的CUDA都是指CUDA Runtime API（除非是驱动开发人员）
    - CUDA Driver API向下兼容（旧版本）CUDA Runtime API，CUDA Runtime API版本号必须小于等于 CUDA Driver API版本号
    - CUDA Driver API：
        - GPU设备的抽象层，通过提供一系列接口来操作GPU设备，性能好，但编程难度高
        - 由GPU Driver Installer安装
        - 典型文件有libcuda.so，nvidia-smi查询的就是此类API
    - CUDA Runtime API：
        - 是对CUDA Driver API进行了一定的封装，从而降低编程难度
        - 同一个机器可安装多个版本
        - 有多种安装方法，包括CUDA Toolkit installer安装、pytorch安装包安装
        - 典型文件有libcudart.so/nvcc，nvcc --version查询的就是此类API
- 相关安装包区别
    - CUDA Toolkit Installer：通常集成了GPU Driver Installer，此时Runtime API与Driver API的版本应该一致。但如果单独进行GPU Driver Installer安装，版本有可能不一致
    - GPU Driver Installer：包含GPU/显卡驱动，可单独安装和升级
    - Pytorch： PyTorch安装包本身自带CUDA Runtime API，只包含库文件，不包含nvcc
- 相关命令区别
    - nvidia-smi: 
        - 管理和监控NVIDIA GPU设备，显示的是Driver版本，以及该Driver支持的最高CUDA Runtime API版本
        - 只知道它自身构建时的CUDA Driver版本??，并不知道安装了什么版本的CUDA Runtime API，甚至不知道是否安装了CUDA Runtime API
    - nvcc: 
        - nvcc是一个编译器，显示的是它自身构建时的CUDA Runtime API版本
        - 一般是在安装CUDA Runtime API时附带的，系统中不一定存在nvcc，与CUDA Runtime API的安装方法有关
        - 只知道它自身构建时的CUDA Runtime API版本，并不知道安装了什么版本的GPU Driver，甚至不知道是否安装了Driver，且在一个系统有多套CUDA Runtime API时，需要明确实际执行的是哪个CUDA Runtime API版本对应的nvcc
    - torch.version.cuda: pytorch实际使用的CUDA Runtime API版本

设置CUDA同步执行，方便统计执行耗时：

```
# python
torch.cuda.synchronize()
start_time = time.time()
outputs = civilnet(img)
torch.cuda.synchronize()
print('gemfield model_time: ',time.time()-start_time)

# C++
#include <chrono>
#include <c10/cuda/CUDAStream.h>
#include <ATen/cuda/CUDAContext.h>
start = std::chrono::system_clock::now();
output = civilnet->forward(inputs).toTensor();
at::cuda::CUDAStream stream = at::cuda::getCurrentCUDAStream();
AT_CUDA_CHECK(cudaStreamSynchronize(stream));
forward_duration = std::chrono::system_clock::now() - start;
msg = gemfield_org::format(" time: %f",  forward_duration.count() );
std::cout<<"civilnet->forward(inputs).toTensor() "<<msg<<std::endl;
```

可以设置以下环境变量来近似设置CUDA同步执行模式：

```
export CUDA_LAUNCH_BLOCKING=1
```

参考文献：

[CUDA是什么](https://chenglu.me/blogs/what-is-cuda)

[CUDA驱动版本与运行版本不匹配问题详解](https://blog.csdn.net/weixin_45766759/article/details/114677710)

[不同命令查看cuda版本的区别](https://www.cnblogs.com/ining/p/17069111.html)

### Torch

查看Pytorch能否利用GPU计算能力
```
>>> import torch
>>> print(torch.cuda.is_available())
```

查看编译Pytorch release版本时使用的CUDA版本
```
>>> import torch
>>> torch.version.cuda
```

查看Pytorch实际运行时使用的CUDA版本
```
>>> import torch
>>> import torch.utils
>>> import torch.utils.cpp_extension
>>> torch.utils.cpp_extension.CUDA_HOME
```

pytorch相关安装包下载地址
```
https://download.pytorch.org/whl/
https://download.pytorch.org/whl/cu110/torch-1.7.0%2Bcu110-cp38-cp38-linux_x86_64.whl
pip install torch-1.7.0+cu110-cp38-cp38-linux_x86_64.whl
https://download.pytorch.org/whl/cu110/torchvision-0.8.2+cu110-cp38-cp38-linux_x86_64.whl
pip install torchvision-0.8.2+cu110-cp38-cp38-linux_x86_64.whl
```

torchvision版本适配关系
```
https://pypi.org/project/torchvision/
```

使用torch.jit.script()将pth类型模型导出为pt类型时
```
serialized_model = torch.jit.script(netG)
serialized_model.save('model.pt')
```
输出以下报错：
```
torch.jit.frontend.NotSupportedError: Compiled functions can't take variable number of arguments or use keyword-only arguments with defaults:
```
原因：jit不支持DataParallel，解决方法为不使用nn.DataParallel()，且将模型参数的key的module.前缀删除，可参考[这篇文章](https://szukevin.site/2021/02/27/MODNet%E8%BD%AC%E6%88%90torchscript%E5%BD%A2%E5%BC%8F%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/)

### TensorBoard

执行`tensorboard --logdir=LOG_PATH`，然后在浏览器中访问`http://localhost:6006/`便可以查看到图形

### 其他

