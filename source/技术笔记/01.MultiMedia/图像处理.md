# 滤波

可用于降噪、模糊等目的。

高斯滤波  
双边滤波  
导向滤波  
NonLocalMeans  
BM3D
选择性模糊滤波  

[Guided Image Filtering](http://kaiminghe.com/eccv10/eccv10ppt.pdf)  
[导向滤波(Guided Filter)](https://blog.csdn.net/sinat_36264666/article/details/77990790?locationNum=7&fps=1)  
[导向滤波原理（Guided Filter）](https://blog.csdn.net/edogawachia/article/details/78872932)  
[暗通道先验之Guided filter导向滤波](https://zhuanlan.zhihu.com/p/36813673)  
[传统图像去雾/增强算法相关论文之暗通道先验](https://zhuanlan.zhihu.com/p/36785699)  

# 噪声估计

# 降噪

需要考虑因素：
1. 噪声类型
2. 噪声强度
3. 噪声频率：低频噪声对人眼主观的影响大于高频噪声，且低频段人眼对色度的分辨能力大于亮度，达到一定频率后，人眼对色度分辨能力迅速衰减，对亮度分辨能力则先增大再衰减
3. 纹理特征：平坦区域的像素变化主要由噪声引起，可加大降噪强度，充分去除噪声，纹理区域的像素变化主要由纹理引起，需要控制降噪强度，尽量保留细节
4. 亮度特征：光照不足时，各通道的期望值都较小，此时噪声的比重变大，通常暗区的噪声强于亮区的噪声，且人眼对暗区更敏感，暗区的噪声更容易被感知
5. 色度特征：主流的感光sensor都是使用硅基材料制作的，硅材料在蓝色波段的光电转换效率较低，通常蓝色通道的噪声最强，可以对蓝色通道采用更大的降噪强度

# 锐化

USM锐化  
拉普拉斯锐化  

# 自动白平衡(AWB)

## 灰度世界算法

假定世界是灰色的，图像画面RGB各通道的平均值应该是相等的，以此出发计算RGB各通道的增益因子。具体过程：

1. 计算图像的RGB各通道的平均值：Ravg, Gavg, Bavg
2. 计算图像的RGB各通道的平均值的平均值：Gray = (Ravg + Gavg + Bavg)/3
3. 计算RGB各通道的增益因子：Rgain = Gray / Ravg, Ggain = Gray / Gavg, Bgain = Gray / Bavg
4. 图像各像素的RGB值分别与各通道增益因子相乘，得到白平衡后的图像像素值

以上第4步后，有可能出现像素值溢出255的情况，一般有2种处理方法：

1. 截断，超出255的数值全部截断为255
2. 计算输出后的像素最大值，然后线性映射到[0, 255]范围内
一般情况下，第1种的画质更好，第2种方法会导致图像整体偏暗。

## 完美反射算法
## 动态阈值算法

# 形态学处理

## 膨胀

## 腐蚀

## 开运算

开运算为先腐蚀再膨胀，看上去把细微连在一起的两块目标分开了。

- 开运算能够除去孤立的小点，毛刺和小桥，而总的位置和形状不便。
- 开运算是一个基于几何运算的滤波器。
- 结构元素大小的不同将导致滤波效果的不同。
- 不同的结构元素的选择导致了不同的分割，即提取出不同的特征。

[图像开运算与闭运算](https://zhuanlan.zhihu.com/p/46306138)

## 闭运算

闭运算为先膨胀再腐蚀，看上去将两个细微连接的图块封闭在一起。

- 闭运算能够填平小湖（即小孔），弥合小裂缝，而总的位置和形状不变。
- 闭运算是通过填充图像的凹角来滤波图像的。
- 结构元素大小的不同将导致滤波效果的不同。
- 不同结构元素的选择导致了不同的分割。

[图像开运算与闭运算](https://zhuanlan.zhihu.com/p/46306138)

# Pulldown

作用是将电影制式转换为电视制式，使得电影内容可以在电视机上播放。
电影原本是24fps，如果要在NTSC制式的电视上播放，就需要进行胶卷过带，在此过程中，会把影片经过`3:2 pulldown`转为30fps。

TC（Telecine，胶卷过带）的实现方法是：

把电影原本的 `1 2 3 4` 四个帧，每个帧根据扫瞄线的奇偶性拆成奇数场（Odd Field）和偶数场（Even Field），拆成 `1o 1e 2o 2e 3o 3e 4o 4e`，然后每两个场再重新组合成一个帧，变成 `A  B  C  D  E` 五个帧。。组合方法如下（以 Odd Field First 的顺序）
```
1o 1e - 2o 2e - 2o 3e - 3o 4e - 4o 4e
  A   -   B   -   C   -   D   -   E  
```
这样由原本的 4 帧变成 5 帧，就能从 24fps 转为 30fps。

IVTC（Inverse Telecine，反胶卷过带）是相反的逆过程，
作用是将 30fps 转回 24fps，帧数减少 20%，而且画面无交错容易压缩，所以压缩编码后画质会好很多。

大部分胶卷过带由硬件实现，也有软件实现的“软”胶卷过带算法，
更多解释见[这里](http://trac.handbrake.fr/wiki/Telecine)。


# deinterlacing（去交错）

## 算法类型

### 单一场去交错

如line dobule

将单一场放大成帧大小，帧率不变。
优点是非常简单且快速，成本低，
缺点是画质看起来不锐利，若影像中含有横向的细线，在某些场中刚好没有扫描到，重建出来的影像的细线视觉上会有闪烁的感觉。

### 场间去交错

如weave

将连续的两场直接结合为一帧，不做任何修改，帧率减半。
画质比line double好，
运动内容会有明显的横向条纹和锯齿，若结合的两场正好是场景切换，则合成结果会有鬼影现象。

### 动态适应性去交错

侦测影像中何处是静止的，何处是运动的，静止区域使用场间去交错从而得到垂直方向的完整内容信息，运动区域使用单一场去交错从而避免横向条纹、锯齿和鬼影。

运动侦测算法对最终结果相当重要。

### 动态补偿去交错

根据邻近场使用运动估计预测画面中物体的运动，得到运动向量，使用前一场和运动向量重建出一个新的场，再将此两场合并完成去交错。

重建画质非常好，但需要大量的计算，速度慢。

## 算法

ffmpeg中与deinterlacing相关的有以下filter：
```
idet         : Detect video interlacing type
il           : Deinterleave or interleave fields
yadif        : Yet Another Deinterlacing filter
bwdif        : Bob Weaver Deinterlacing Filter
estdif       : Edge Slope Tracing Deinterlacing Filter
w3fdif       : Weston 3 Field Deinterlacing Filter
mcdeint      : motion-compensation deinterlacing
bwdif_vulkan : Deinterlacer using bwdif, the "Bob Weaver Deinterlacing Filter" algorithm, implemented on the GPU using Vulkan
libplacebo   : 支持weave, bob, yadif, bwdif
```

### yadif

工作原理是比较框架並決定填充线条的最佳方式。可以处理大多数影片，一般用途的首选。

```
ffmpeg -i interlacing.mp4 -vf yadif=mode=send_frame -tag:v hvc1 -c:v libx265 -x265-params lossless=1:info=0 yadif.mp4
```

### bwdif

使用一种检查过去和未來帧的方法，以決定如何填充这些行。画质比yadif更高，尤其是在具有大量运动的影片中。

```
ffmpeg -i interlacing.mp4 -vf bwdif=mode=send_frame -tag:v hvc1 -c:v libx265 -x265-params lossless=1:info=0 bwdif.mp4
```

### estdif
### w3fdif
### mcdeint

# demosaic

## 双线性插值法
## 色差一致性法
## HA插值法法(Hamilton & Adams)
## LED算法

[Understanding ISP Pipeline - Demosaicking](https://zhuanlan.zhihu.com/p/144651850)  
[ISP算法简述与逻辑实现-demosaic](https://zhuanlan.zhihu.com/p/512357230)  
[ISP图像处理之Demosaic算法及相关](https://zhuanlan.zhihu.com/p/170610956)  

# Tone mapping

[这篇文章](https://www.nxrte.com/jishu/yinshipin/22927.html)
介绍了ffmpeg-tonemap滤镜和zimg共同进行Filmic色调映射算法的过程和相关代码。

[Uncharted2: Hdr Lighting](https://www.slideshare.net/slideshow/hable-john-uncharted2-hdr-lighting/3602588)
是Filmic Tone mapping (Hable) 算法的原作者的分享材料。

## Filmic

$$
\begin{align}
g(x) &= \frac {x  (x  a + b  c) + d  e} {x  (x  a + b) + d  f} - \frac {e} {f} 
  = \frac {ax^2 + bcx + de} {ax^2 + bx + df} - \frac {e} {f} \\
f(x) &= \frac {g(x)} {g(p)}
\end{align}
$$

其中，$x$和$p$为经过`npl`归一化的线性域输入亮度和输入峰值亮度，$y$为映射后的最终亮度。

Uncharted2的默认参数为

$$
a = 0.22, b = 0.30, c = 0.10, d = 0.20, e = 0.01, f = 0.30
$$

FFmpeg tonemap filter的默认参数为

$$
a = 0.15, b = 0.50, c = 0.10, d = 0.20, e = 0.02, f = 0.30
$$

## Reinhard

$$
\begin{align}
m &= \frac {1 - k} {k} \\
f(x) &= \frac {x (p + m)} {(x + m) p} 
   = \frac {px + mx} { px + mp }
\end{align}
$$

其中，$p$为经过`npl`归一化的线性域峰值亮度，$k$为可调节参数，FFmpeg tonemap filter默认为0.5。

## Mobius

$$
\begin{align}
a &= - \frac {k^2 (p - 1)} {k^2 - 2 k + p} \\
b &= \frac {k^2 - 2 k p + p} {p - 1} \\
f(x) &= \left\{\begin{matrix}
  & x, & x <= k \\
  & \frac {(b^2 + 2 b k + k^2) (x + a)} {(b - a) (x + b)}, & x > k
\end{matrix}\right.
\end{align}
$$

其中，$p$为经过`npl`归一化的线性域峰值亮度，$k$为可调节参数，FFmpeg tonemap filter默认为0.3。

## ACES

$$
\begin{align}
f(x) &= \frac {x (a x + b)} {x (c x + d) + e} = \frac {a x^2 + bx} { c x^2 + dx + e}
\end{align}
$$

FFmpeg tonemap filter的默认参数为

$$
a=2.51, b=0.03, c=2.43, d=0.59, e=0.14
$$

## Gamma

$$
\begin{align}
f(x)
&= \left\{\begin{matrix}
  & \frac {\left (\frac {0.05} {p} \right )^{1 / \gamma} x} {0.05}, & x <= 0.05 \\
  & \left ( \frac {x} {p} \right )^ {1 / \gamma}, & x > 0.05
\end{matrix}\right. 
\end{align}
$$

其中，$p$为经过`npl`归一化的线性域峰值亮度，$\gamma$为可调节参数，FFmpeg tonemap filter默认为1.8。

令$\gamma = \frac {1} {\gamma}$，默认值修改为$\frac {1} {1.8}$，则有

$$
\begin{align}
f(x) &= \left\{\begin{matrix}
  &  \frac {\left (\frac {0.05} {p} \right )^{\gamma}} {0.05} x , & x <= 0.05 \\
  & \left ( \frac {x} {p} \right )^ {\gamma} , & x > 0.05
\end{matrix}\right.
\end{align}
$$

又令
$$
g(x) = \left ( \frac {x} {p} \right ) ^ \gamma
$$

则

$$
\begin{align}
f(x) &= \left\{\begin{matrix}
  &  \frac {g(0.05)} {0.05} x , & x <= 0.05 \\
  & g(x) , & x > 0.05
\end{matrix}\right.
\end{align}
$$

# 曲线工具

通过研究`GIMP`代码可发现，曲线工具由贝塞尔曲线实现。

算法原理为根据用户设置的锚点进行分段计算，大概计算过程为：

- 假设当前需要计算由`[P2, P3]`区间的输出曲线，函数输入参数为`P1 P2 P3 P4`四个锚点
- `P1 P4`分别是`P2 P3`的相邻锚点，同时作为外部控制点控制`[P2, P3]`区间的曲线形状
- 在`[P2, P3]`区间插入内部控制点`C1`和`C2`，x坐标分别位于`[P2, P3]`线段的$\frac 1 3$和$\frac 2 3$位置处
- 计算`C1`对应的y坐标`y1`，使得`C1-P2`斜率与`P1-P3`斜率相等
- 计算`C2`对应的y坐标`y2`，使得`C2-P3`斜率与`P2-P4`斜率相等
- 使用`P2 C1 C2 P3`的y坐标值，代入标准的贝塞尔曲线函数，即可算出`[P2, P3]`的输出值

具体可参考GIMP的[app/core/gimpcurve.c](https://gitlab.gnome.org/GNOME/gimp/-/blob/master/app/core/gimpcurve.c)代码文件的`gimp_curve_plot()`函数。

# Focus Peaking / Peaking Highlights

根据Adobe的描述，这项技术可用于辅助用户在拍摄前识别哪些画面处于对焦区，比如，当用户使用没有自动对焦的镜头拍摄时，这项技术可计算出peak contrast area，并在Live View中使用其它色彩高亮显示。

这项技术的优势是允许在具备该技术的相机上使用旧的缺乏自动对焦能力的镜头，适用于一些通过祼眼难以判断对焦区域的场景，比如，低光照环境等。

[Adobe - What is focus peaking?](https://www.adobe.com/creativecloud/photography/discover/focus-peaking.html)
[Focus Peaking - An Algorithm](https://paulbourke.net/miscellaneous/focuspeaking/)
